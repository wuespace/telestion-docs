---
title: Writing a static dialog
# e.g., "Publishing messages to the event bus" or "Installing a dependency using npm"

description:
  Dialogs are an essential part of every UI framework. Learn how you
  can efficiently write and configure static dialogs with the Telestion Client Common package.
---

<!--
Tutorial
========

=== When to use this template:
Use this template when you want to give a quick, step-by-step tutorial for solving a specific
technical problem. Tutorials allow the reader to learn how to implement something within
their projects quickly.

=== When not to use this template:
When your article focuses more on a concept/technology and is not rooted in a specific technical
problem ("how to do XY?"), consider using a guide instead.

=== Guide or Tutorial
A tutorial provides a quick, technical "step-by-step" tutorial for a
given problem. Thus, a guide describes less the handling of a specific problem
and more the general interaction of the reader with a given concept.

Example with npm articles:
- "npm": (Concept, explaining what npm is)
- "Installing a dependency with npm" (Tutorial, providing a quick tutorial to
  solve a technical problem)
- "Managing dependencies with npm" (Guide, including both technical knowledge, but
  also best practices and more)

=== Writing tips:
- Write in the present tense
- Use neutral pronouns (they/them instead of he/she and him/her)
- Be respectful to everyone
- Be aware of the potential for cultural misunderstandings
- Provide explanations for what you do, but focus on the step-by-step guide
  without deeply explaining every technical decision and why it's best prcatice
  to do so (you can describe best practices in a guide, a tutorial must focus on
  keeping the "step by step" flow going)
-->

<!-- Relevant imports: -->

import { Reference, Image } from '/components';

<!-- Short description of what the article covers: -->

In this tutorial, we write a static dialog for a widget in the web client.
A static dialog has no state and therefore doesn't change its content during rendering.

:::info Prerequisites

To complete this tutorial, you should be familiar with TypeScript language
and the React framework. It is benefical to have basic knowledge about the Telestion client part
and Adobe's React Spectrum UI library.

:::

## What we'll build

In this tutorial, we'll build a static dialog in a widget which asks the user for a confirmation
to send a specific telecommand.

The full code for this tutorial will look like this:

```tsx title='widget.tsx'
import { useState } from 'react';
import { ActionButton, Flex, TextField, View } from '@adobe/react-spectrum';
import { showDialog } from '@wuespace/telestion-client-common';

function sendTC(command: string): void {
	console.log('Send telecommand: ' + command);
}

export function Widget() {
	const [command, setCommand] = useState('default-command');

	const handle = () => {
		showDialog('custom-tc', {
			title: 'Send telecommand',
			content: 'Are you sure you want to send the telecommand "' + command + '"?',
			initialState: undefined
		}).then(() => sendTC(command));
	};

	return (
		<View padding="size-200">
			<Flex direction="column" gap="size-100">
				<TextField
					label="Telecommand"
					width="100%"
					value={command}
					onChange={setCommand}
				/>
				<ActionButton onPress={handle}>Send</ActionButton>
			</Flex>
		</View>
	);
}
```

## Step 1: Generate a new widget

Let's create a new widget with the Telestion Client CLI.

```sh
tc-cli generate widget custom-tc-widget
```

It will generate the required files for you.
Now navigate to `src/widgets/custom-tc-widget` and open the `widget.tsx` source file.

If you already created a widget, open the widget component source file to begin.

<Reference
	to="https://github.com/wuespace/telestion-client/tree/main/packages/telestion-client-cli">
	telestion-client-cli
</Reference>

## Step 2: Define the widget structure

You will be greeted with a `Heading` component generated by the CLI.

Let's remove it and add a `View` component with a `Flex` component as child:

```tsx file='widget.tsx' {1,4-6,8-10}
import { Flex, View } from '@adobe/react-spectrum';

export function Widget() {
	return (
		<View>
			<Flex>
				{/* ... */}
			</Flex>
		</View>
	);
}
```

Add some padding to the `View` and configure the `Flex` to column mode with a gap size.

```tsx file='widget.tsx' {5-6}
import { Flex, View } from '@adobe/react-spectrum';

export function Widget() {
	return (
		<View padding="size-200">
			<Flex direction="column" gapsize="size-100">
				{/* ... */}
			</Flex>
		</View>
	);
}
```

To input and send custom telecommands, we need a text field and a button.
Add these two components into the `Flex` container.
Give the `TextField` a label for better usability and set the width to `100%`:

```tsx file='widget.tsx' {1,7-8}
import { ActionButton, Flex, TextField, View } from '@adobe/react-spectrum';

export function Widget() {
	return (
		<View padding="size-200">
			<Flex direction="column" gapsize="size-100">
				<TextField label="Telecommand" width="100%" />
				<ActionButton>Send</ActionButton>
			</Flex>
		</View>
	);
}
```

Now, add the widget to your dashboard.
If you need help, please take a look at our tutorial to bootstrapping a widget:

<Reference to="/client/tutorials/bootstrapping-a-widget/">
	Bootstrapping a widget
</Reference>

Now, start the Web Client and you should see something like this:

<Image
  src="/img/dialogs/simple-dialog-structure.png"
  alt="The custom telecommand widget"
  center
/>

## Step 3: Add some state

To send custom telecommands, we need access to the user input from the `TextField`.
Let's add a React state which holds the current user input
and switch the `TextField` from uncontrolled to controlled mode:

```tsx file='widget.tsx' {1,5,10-15}
import { useState } from 'react';
import { ActionButton, Flex, TextField, View } from '@adobe/react-spectrum';

export function Widget() {
	const [command, setCommand] = useState('default-command');

	return (
		<View padding="size-200">
			<Flex direction="column" gapsize="size-100">
				<TextField
					label="Telecommand"
					width="100%"
					value={command}
					onChange={setCommand}
				/>
				<ActionButton>Send</ActionButton>
			</Flex>
		</View>
	);
}
```

The `useState` hook from React provides the current state and a function to update it.
These two things are provided to the `TextField` which now renders the current command
and updates it on user input.

Let's add an `onPress` event handler to react on send requests from the `ActionButton`:

```tsx file='widget.tsx' {4-6,11-13,24}
import { useState } from 'react';
import { ActionButton, Flex, TextField, View } from '@adobe/react-spectrum';

function sendTC(command: string): void {
	console.log('A telecommand was sent: ' + command);
}

export function Widget() {
	const [command, setCommand] = useState('default-command');

	const handle = () => {
		sendTC(command);
	};

	return (
		<View padding="size-200">
			<Flex direction="column" gapsize="size-100">
				<TextField
					label="Telecommand"
					width="100%"
					value={command}
					onChange={setCommand}
				/>
				<ActionButton onPress={handle}>Send</ActionButton>
			</Flex>
		</View>
	);
}
```

We introduce an external function which represents a call method
to an external API to really send the telecommand.

Next we create an event handler which sends the currently entered telecommand
to the previously defined external function.
The `ActionButton` calls the event handler if the user presses the action button.

## Step 4: Show a dialog before sending

Because telecommands can be generally disruptive to the remote system,
it's useful to add a modal to prevent sending of unintended commands by the user.

Import the `showDialog` function from the `@wuespace/telestion-client-common` package
and include it into the event handler:

```tsx file='widget.tsx' {3,13-17}
import { useState } from 'react';
import { ActionButton, Flex, TextField, View } from '@adobe/react-spectrum';
import { showDialog } from '@wuespace/telestion-client-common';

function sendTC(command: string): void {
	console.log('Send telecommand: ' + command);
}

export function Widget() {
	const [command, setCommand] = useState('default-command');

	const handle = () => {
		showDialog('custom-tc', {
			title: 'Send telecommand',
			content: 'Are you sure you want to send the telecommand "' + command + '"?',
			initialState: undefined
		}).then(() => sendTC(command));
	};

	return (
		<View padding="size-200">
			<Flex direction="column" gapsize="size-100">
				<TextField
					label="Telecommand"
					width="100%"
					value={command}
					onChange={setCommand}
				/>
				<ActionButton onPress={handle}>Send</ActionButton>
			</Flex>
		</View>
	);
}
```

The `showDialog` function needs a unique id across the Web Client and a configuration object.

The object is the main part of the dialog.
It defines the content of the different parts in the dialog.
For example, the `title` property defines the content in the upper left corner
or the `content` property the center part of the dialog.

For a better understanding take a look at the Spectrum design guidelines for a modal:

<Reference to="https://spectrum.adobe.com/page/dialog/">
	Spectrum Dialog
</Reference>

Here we only use simple strings as parameters
and build a "dynamic" string out of the currently entered command.

The dialog can also be stateful.
Therefore the `initialState` property defines the initial state of the dialog.
In this example we need no state, so we set the dialog state to `undefined`.

When the `showDialog` function gets called, a dialog opens with the given configuration.
If the user confirms, the returned promise resolves.
If the user cancels the dialog, the promise rejects.

Here we react on the success of the promise and send the telecommand.

Now go back to your open Web Client and press the "Send" button.
A dialog should open, asking you if you really want to send this telecommand:

<Image
  src="/img/dialogs/simple-dialog-open-dialog.png"
  alt="The open telecommand confirm dialog"
  center
/>



## Next steps

<!-- Short concluding sentence: -->

That's it! You've created your first dialog! :tada:

As we mentioned earlier, the dialog itself can be stateful
and is therefore much more customizable.

In the next tutorial, we'll create a more complex example involving stateful dialogs.

<!-- Links to next steps/related articles -->

<Reference to="/client/tutorials/writing-a-stateful-dialog/">
	Writing a stateful dialog
</Reference>

<!--
Snippets
--------

<Reference to="../other-article">
    Relative Link to other article
</Reference>

<Reference to="https://www.example.com">
    Example Website
</Reference>
-->
