---
title: Adding configuration options
# e.g., "Publishing messages to the event bus" or "Installing a dependency using npm"

description:
  Verticles work best when you can quickly adjust their parameters and re-use
  them. Learn how to make your Verticles configurable.
---

<!--
Tutorial
========

=== When to use this template:
Use this template when you want to give a quick, step-by-step tutorial for solving a specific
technical problem. Tutorials allow the reader to learn how to implement something within
their projects quickly.

=== When not to use this template:
When your article focuses more on a concept/technology and is not rooted in a specific technical
problem ("how to do XY?"), consider using a guide instead.

=== Guide or Tutorial
A tutorial provides a quick, technical "step-by-step" tutorial for a
given problem. Thus, a guide describes less the handling of a specific problem
and more the general interaction of the reader with a given concept.

Example with npm articles:
- "npm": (Concept, explaining what npm is)
- "Installing a dependency with npm" (Tutorial, providing a quick tutorial to
  solve a technical problem)
- "Managing dependencies with npm" (Guide, including both technical knowledge, but
  also best practices and more)

=== Writing tips:
- Write in the present tense
- Use neutral pronouns (they/them instead of he/she and him/her)
- Be respectful to everyone
- Be aware of the potential for cultural misunderstandings
- Provide explanations for what you do, but focus on the step-by-step guide
  without deeply explaining every technical decision and why it's best prcatice
  to do so (you can describe best practices in a guide, a tutorial must focus on
  keeping the "step by step" flow going)
-->

<!-- Relevant imports: -->

import { Reference, Image } from '/components';

<!-- Short description of what the article covers: -->

While it is already great to have a Verticle that does its job, the effort of
making it configurable, and thus, reusable, is minimal.

Developing your Verticle in a re-usable way means that it'll take far less time
(and maybe not even re-compilation/a new release) to adjust to changed mission
parameters.

:::info Prerequisites

To complete this tutorial, you should be familiar with writing basic Verticles
and using the `JsonMessage` interface from the Telestion APIs.

:::

## What we'll build

<Reference to="/application/tutorials/using-jsonmessage/">Base Code</Reference>

Based on the code from the
[`JsonMessage` tutorial](/application/tutorials/using-jsonmessage/), we'll add
configurability to our `MessageTransformer` Verticle.

After the tutorial, our Verticle will look like this:

```java title='MessageTransformer.java' {3-4,5,7-9,11,18,20-23,28-36,42,45,46}
package de.wuespace.telestion.project.example;

import com.fasterxml.jackson.annotation.JsonProperty;
import de.wuespace.telestion.api.message.JsonMessage;
import de.wuespace.telestion.api.verticle.TelestionConfiguration;
import de.wuespace.telestion.api.verticle.TelestionVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;

public class MessageTransformer extends TelestionVerticle<MessageTransformer.Configuration> {

	public static void main(String[] args) throws InterruptedException {
		var vertx = Vertx.vertx();

		// [...]

		var config = new JsonObject().put("multiplier", 6);

		vertx.deployVerticle(
			new MessageTransformer(),
			new DeploymentOptions().setConfig(config)
		).onSuccess(res -> {
			// [...]
		});
	}

	public record Configuration(
			@JsonProperty String inAddress,
			@JsonProperty String outAddress,
			@JsonProperty int multiplier
	) implements TelestionVerticle {
		public Configuration() {
			this("input", "output", 2); // default values
		}
	}

	@Override
	public void onStart() {
		var eb = getVertx().eventBus();

		eb.consumer(getConfig().inAddress(), event -> {
			JsonMessage.on(IntegerMessage.class, event, message -> {
				int received = message.value();
				var output = new IntegerMessage(received * getConfig().multiplier());
				eb.publish(getConfig().outAddress(), output.json());
			});
		});
	}
}
```

## Step 1: Defining the `record Configuration` for the Verticle

The Telestion APIs re-use the `JsonMessage` interface to deal with type safety
in configuration options. The reason for this is basically the same as with the
event bus: Vert.x natively uses `JsonObject` instances. While in specific,
dynamic use-cases, this is useful, we typically want our configuration to be
type safe, which is why we can use convenience functions that are very similar
to the `JsonMessage` APIs.

Since our Verticle is rather basic, there are only three parameters that we
could expose to be configurable:

1. the event bus address we're listening to
1. the event bus address we're publishing to
1. the multiplier

Add a `record Configuration implements TelestionConfiguration` containing these fields as a
member of our `MessageTransformer` Verticle:

:::tip

It has become a convention to make the configuration records members of their
Verticle and name them `Configuration`.

:::

```java title="MessageTransformer.java" {11-16}
package de.wuespace.telestion.project.example;

// [...]

public class MessageTransformer extends TelestionVerticle<GenericConfiguration> {

	public static void main(String[] args) throws InterruptedException {
		// [...]
	}

	public record Configuration(
			@JsonProperty String inAddress,
			@JsonProperty String outAddress,
			@JsonProperty int multiplier
	) implements TelestionConfiguration {
	}

	@Override
	public void onStart() {
		// [...]
	}
}
```

Now that we have defined a configuration record, let's take a look at how we can
apply it in our Verticle.

## Step 2: Adjusting the Verticle structure

To actually use our configuration, we need to make some slight adjustments to
the existing code:

```java title='MessageTransformer.java' {5}
package de.wuespace.telestion.project.example;

// [...]

public class MessageTransformer extends TelestionVerticle<MessageTransformer.Configuration> {
	// [...]
}
```

Now, the generic type enters the game.
We need to give the `TelestionVerticle` class a hint about our new configuration.
So we replace the `GenericConfiguration` type
with our configuration type `MessageTransformer.Configuration`.

With that, our Verticle is fully set up to handle our configuration objects.
Next, let's take a look at how we can retrieve configuration values to actually
use them within our Verticle.

## Step 3: Retrieving configuration values

When the Verticle starts, it automatically retrieves
and merges the configuration provided by the `Vertx` context with the default configuration.

Then it maps the merged configuration back to our `Configuration` type.

To access the configuration, use one of the `TelestionVerticle`'s convenience methods:

```java title='MessageTransformer.java' {}
package de.wuespace.telestion.project.example;

// [...]
import de.wuespace.telestion.api.config.Config;
// [...]

public class MessageTransformer extends TelestionVerticle<MessageTransformer.Configuration> {
	// [...]

	@Override
	public void onStart() {
		var eb = getVertx().eventBus();

		eb.consumer(getConfig().inAddress(), event -> {
			JsonMessage.on(IntegerMessage.class, event, message -> {
				int received = message.value();
				var output = new IntegerMessage(received * getConfig().multiplier());
				eb.publish(getConfig().outAddress(), output.json());
			});
		});
	}

	// [...]
}
```

As you can see, we can now just access configuration options by using the
`getConfig` method provided by the `TelestionVerticle` base class.

To access the configuration in other types, take a look at the API reference of the `TelestionVerticle`:

<Reference to="https://javadoc.io/doc/de.wuespace.telestion/telestion-api/latest/de/wuespace/telestion/api/verticle/TelestionVerticle.html">
	<code>TelestionVerticle</code> API reference
</Reference>

## Step 4: Adding default configuration parameters

Having every single configuration option for every single Verticle one deploys
can be quite cumbersome.

Therefore, it is good practice to define the default values for your
`Configuration` record.

And a default constructor with no arguments defining the default values
to our `Configuration` class:

```java title="MessageTransformer.java" {14-16}
package de.wuespace.telestion.project.example;

// [...]

public class MessageTransformer extends TelestionVerticle<MessageTransformer.Configuration> {

	// [...]

	public record Configuration(
			@JsonProperty String inAddress,
			@JsonProperty String outAddress,
			@JsonProperty int multiplier
	) implements JsonMessage {
		public Configuration() {
			this("input", "output", 2); // default values
		}
	}

	// [...]
}
```

That's it! The `TelestionVerticle` class will try to load the default configuration
once the Verticle is created.

## Step 5: Adjusting the `main()` method

To test what we've just written, we also need to adjust our main method.

Use `new DeploymentOptions().setConfig(jsonObject)` to pass a configuration
object to the deployed Verticle:

```java title='MessageTransformer.java' {14,16-19}
package de.wuespace.telestion.project.example;

// [...]
import io.vertx.core.DeploymentOptions;
import io.vertx.core.json.JsonObject;

public class MessageTransformer extends TelestionVerticle<MessageTransformer.Configuration> {

  public static void main(String[] args) throws InterruptedException {
		var vertx = Vertx.vertx();

		// [...]

		var config = new JsonObject().put("multiplier", 6);

		vertx.deployVerticle(
			new MessageTransformer(),
			new DeploymentOptions().setConfig(config)
		).onSuccess(res -> {
			// [...]
		});
	}

	// [...]
}
```

That's it. When you now re-run the main method, you should see that we now get a
`value` of `18`, i.e., `6 * 3`.

:::tip

We're using `new JsonObject().put()` instead of `new Configuration()` since it
wouldn't be possible to test our default values if we instantiated a "full"
`Configuration` instance.

:::

## Next steps

<!-- Short concluding sentence: -->

And that's already it. While you may, of course, need to know how to use other
Java functionalities, this is all the Telestion-specific knowledge you need to
write Verticles and even whole extensions for the Telestion projects.

<!-- Links to next steps/related articles -->

<Reference to="https://javadoc.io/doc/de.wuespace.telestion/telestion-api/latest/de/wuespace/telestion/api/verticle/TelestionVerticle.html">
	<code>TelestionVerticle</code> API reference
</Reference>

<!--
Snippets
--------

<Reference to="../other-article">
    Relative Link to other article
</Reference>

<Reference to="https://www.example.com">
    Example Website
</Reference>
-->
